<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building an MCP Server for OpenDota API with FastMCP | Manuel Martinez</title><meta name=keywords content="aws,python,cdk,mcp"><meta name=description content="Introduction
You&rsquo;ve probably heard about the Model Context Protocol (MCP) by now ‚Äî an emerging standard for connecting AI agents to external data sources and tools.
I wanted to explore building a serverless HTTP-based MCP server using the typical APIGW + Lambda pattern that is common in serverless applications, i.e. the way some MCP server provider might want to host MCP servers for public consumption. When thinking about which tools the MCP server should have, I wondered how hard it would be to convert an existing REST API into an MCP server - especially given some standard specifications like OpenAPI."><meta name=author content="Manuel Martinez"><link rel=canonical href=https://manmartgarc.github.io/posts/tech-support/fastmcp-opendota/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://manmartgarc.github.io/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://manmartgarc.github.io/images/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://manmartgarc.github.io/images/favicon.ico><link rel=apple-touch-icon href=https://manmartgarc.github.io/apple-touch-icon.png><link rel=mask-icon href=https://manmartgarc.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://manmartgarc.github.io/posts/tech-support/fastmcp-opendota/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://manmartgarc.github.io/posts/tech-support/fastmcp-opendota/"><meta property="og:site_name" content="Manuel Martinez"><meta property="og:title" content="Building an MCP Server for OpenDota API with FastMCP"><meta property="og:description" content="Introduction You‚Äôve probably heard about the Model Context Protocol (MCP) by now ‚Äî an emerging standard for connecting AI agents to external data sources and tools.
I wanted to explore building a serverless HTTP-based MCP server using the typical APIGW + Lambda pattern that is common in serverless applications, i.e. the way some MCP server provider might want to host MCP servers for public consumption. When thinking about which tools the MCP server should have, I wondered how hard it would be to convert an existing REST API into an MCP server - especially given some standard specifications like OpenAPI."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-24T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-24T00:00:00+00:00"><meta property="article:tag" content="Aws"><meta property="article:tag" content="Python"><meta property="article:tag" content="Cdk"><meta property="article:tag" content="Mcp"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building an MCP Server for OpenDota API with FastMCP"><meta name=twitter:description content="Introduction
You&rsquo;ve probably heard about the Model Context Protocol (MCP) by now ‚Äî an emerging standard for connecting AI agents to external data sources and tools.
I wanted to explore building a serverless HTTP-based MCP server using the typical APIGW + Lambda pattern that is common in serverless applications, i.e. the way some MCP server provider might want to host MCP servers for public consumption. When thinking about which tools the MCP server should have, I wondered how hard it would be to convert an existing REST API into an MCP server - especially given some standard specifications like OpenAPI."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://manmartgarc.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Building an MCP Server for OpenDota API with FastMCP","item":"https://manmartgarc.github.io/posts/tech-support/fastmcp-opendota/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building an MCP Server for OpenDota API with FastMCP","name":"Building an MCP Server for OpenDota API with FastMCP","description":"Introduction You\u0026rsquo;ve probably heard about the Model Context Protocol (MCP) by now ‚Äî an emerging standard for connecting AI agents to external data sources and tools.\nI wanted to explore building a serverless HTTP-based MCP server using the typical APIGW + Lambda pattern that is common in serverless applications, i.e. the way some MCP server provider might want to host MCP servers for public consumption. When thinking about which tools the MCP server should have, I wondered how hard it would be to convert an existing REST API into an MCP server - especially given some standard specifications like OpenAPI.\n","keywords":["aws","python","cdk","mcp"],"articleBody":"Introduction You‚Äôve probably heard about the Model Context Protocol (MCP) by now ‚Äî an emerging standard for connecting AI agents to external data sources and tools.\nI wanted to explore building a serverless HTTP-based MCP server using the typical APIGW + Lambda pattern that is common in serverless applications, i.e. the way some MCP server provider might want to host MCP servers for public consumption. When thinking about which tools the MCP server should have, I wondered how hard it would be to convert an existing REST API into an MCP server - especially given some standard specifications like OpenAPI.\nThe rest of this post will describe how I built an MCP server for the OpenDota API using FastMCP and deployed it to AWS Lambda + API Gateway and some lessons learned along the way.\nIf you don‚Äôt know what Dota 2 is, it‚Äôs a popular multiplayer online battle arena (MOBA) game where two teams of five players compete to destroy each other‚Äôs bases. The OpenDota API provides free access to a wealth of Dota 2 statistics, including player data, match histories, hero stats, and more.\nMotivation What‚Äôs an MCP server? Throughout this post, I‚Äôll use agent to mean an AI system capable of discovering and invoking MCP tools, and user to mean the human interacting with that agent.\nAn MCP server is a service that implements the Model Context Protocol (MCP) specification, allowing AI agents to interact with external tools and data sources in a standardized way. MCP servers expose a unified interface that any compatible agent can use. This is part of the trend of decoupling AI agents from specific API implementations, enabling interoperability across platforms and allowing developers to build once and deploy everywhere and even switch AI backends without rewriting tool integrations.\nSome justifications for MCP servers are:\nEmpower LLM-based AI agents with tools that provide real-time data access since it might not be included in their training data. Think of a weather API or stock prices. Limiting some of the undefined behavior that comes from the next-token-prediction nature of LLMs by providing structured tool interfaces. For example, arithmetic calculations or database queries. Allowing AI agents to leverage specialized external services (e.g., search engines, knowledge bases) that can enhance their capabilities beyond the base LLM. This is especially useful for domain-specific applications or private. For example, an enterprise knowledge base that contains proprietary information not available in public datasets. Transports A key part of the MCP specification is the Transports mechanism, which defines how agents communicate with MCP servers. Initially, the stdio transport was the only option‚Äîagents spawn MCP servers as subprocesses and communicate via standard input/output. However, new mechanisms like HTTP have emerged for remote deployment, allowing MCP servers to be hosted in the cloud and scaled independently.\nFor teams building AI tooling at scale, treating MCP servers like standard cloud services‚Äîdeployed, monitored, and scaled with other infrastructure‚Äîmakes sense. HTTP transport is the natural choice here, enabling you to integrate MCP into a larger ecosystem of sessions, authentication, rate limiting, and observability.\nBut we already have a REST API (at home) There are obviously a trillion existing REST APIs out there - and I wanted to see how easy it would be to convert one of them into an MCP server. Specifically given that there are some API specifications such as OpenAPI that provide machine-readable definitions of REST APIs.\nIt turns out there are a couple of options across multiple languages:\nrmcp-openapi: Can generate MCP servers from OpenAPI specs in Rust fastmcp: A Python framework that can auto-generate MCP servers from OpenAPI specifications openapi-mcp: A Go library to create MCP servers from OpenAPI specs All of these tools do roughly the same thing:\nParse the OpenAPI specification to extract endpoints, parameters, and schemas. Map REST endpoints to MCP tools, converting HTTP methods and paths into tool names and descriptions. Generate the necessary MCP server code to handle tool invocations and translate them into REST API calls. I tried using rmcp-openapi, but ran into issues with the specification parsing; specifically the $ref mechanism. What ended up working was FastMCP‚Äôs OpenAPI integration, but still required some customizations to handle authentication removal and AWS Lambda deployment as we‚Äôll see next.\nArchitecture The goal is to build an MCP server that exposes the entire OpenDota API without introducing any stateful or long-lived servers, allowing AI agents to query Dota 2 statistics programmatically. The MCP server should be a serverless HTTP service deployed to APIGW + Lambda using AWS CDK for infrastructure as code.\nA user can then interact with the MCP server using HTTP requests and any MCP-compatible AI agent.\nSequence Diagram The architecture is very straightforward:\nA Lambda function hosts the FastMCP server that exposes the OpenDota API as MCP tools. API Gateway provides an HTTP endpoint that routes requests to the Lambda function. AI agents can send HTTP requests to the API Gateway endpoint to invoke MCP tools. This project uses:\nFastMCP: Python framework that auto-generates MCP tools from OpenAPI specifications Mangum: ASGI adapter for running FastMCP on AWS Lambda AWS CDK: Infrastructure as code for deploying API Gateway + Lambda UV: Modern Python package manager for dependency bundling AWS Lambda Powertools: Lambda utilities (though Mangum was preferred for ASGI compatibility) Project Structure ‚îú‚îÄ‚îÄ lib/ # CDK stack definitions ‚îú‚îÄ‚îÄ python-lambda/ # Python MCP server code ‚îÇ ‚îú‚îÄ‚îÄ lambda_function.py # AWS Lambda handler with Mangum adapter ‚îÇ ‚îú‚îÄ‚îÄ pyproject.toml # Python de pendencies ‚îÇ ‚îî‚îÄ‚îÄ uv.lock # Locked dependencies for reproducible builds ‚îú‚îÄ‚îÄ cdk.json # CDK configuration ‚îú‚îÄ‚îÄ package.json # Node.js dependencies ‚îî‚îÄ‚îÄ README.md # Quick start \u0026 deployment instructions Is this a good idea? I want to focus on the discussion around whether this automatic conversion from OpenAPI to MCP tools is a good idea in practice. Feel free to skip my meandering thoughts and jump to the implementation details if you just want to see how it was built.\nThere‚Äôs a good write-up by Jeremiah Lowin, the creator of FastMCP, on why this approach can be problematic in practice. The gist of it is that while automatic conversion is convenient, it often leads to bloated and inefficient agent interfaces that are hard to use effectively. Definitely recommend reading his post for a deeper dive into this topic - I‚Äôll just summarize a few key points here:\nPurpose: REST APIs often have dozens or hundreds of endpoints. These are designed to be consumed by applications with specific use cases in mind. In contrast, MCP tools are intended to be more general-purpose and composable, allowing for greater flexibility in how they are used. Probably the main issue here is that OpenAPI specs are written for humans and lack the semantic clarity, i.e. natural language context, that explains why a tool should be used and not just how to use it.\nContext: Each MCP tool that‚Äôs available to an AI agent adds to the context window that the agent needs to consider when making decisions, i.e. the mechanism through which an agent can discover and invoke tools is by their descriptions being included in the prompt context. The main concern here is that each MCP server and its tools is eating up precious context. Additionally, ff you have too many tools, the agent may struggle to identify the most relevant ones for a given task - think of overlapping descriptions, i.e. some tools may have very similar names or functionalities, making it hard for the agent to choose the right one. This can lead to confusion and suboptimal tool usage.\nCycle Length: REST APIs response times are usually in the order of tens to hundreds of milliseconds. It‚Äôs common to fire off multiple API calls in quick succession to gather data. However, each MCP tool invocation involves additional overhead because even finding which tool to call requires an inference step based on the tool metadata. Then once the tool is selected, the agent has to generate a new prompt that includes the tool call, send it to the MCP server, wait for the response, and then process the result - which is another inference step. This adds significant latency compared to direct API calls. In practice, each MCP tool invocation can be orders of magnitude slower than a direct API call. If an agent has to make many tool calls to accomplish a task, the overall latency can become prohibitive.\nSo is it a good idea to auto-convert REST APIs to MCP tools and call it a day? No. Is it a good way to quickly prototype an MCP server and experiment with agent interactions? Absolutely. Just be aware of the limitations and be prepared to refine the tool set for production use. Most OpenAPI to MCP parsers allow you to customize which endpoints get included as tools, so you can easily curate a more focused tool set right off the bat - although this is not a substitute for thoughtful tool design.\nImplementation Overall the implementation is fairly straightforward thanks to FastMCP‚Äôs OpenAPI integration and Mangum for ASGI compatibility with AWS Lambda.\nTake a look at the full source code for this project on GitHub.\nAuthentication Removal One challenge was that the OpenDota API supports both public and authenticated endpoints. The public API is accessible without authentication, but the OpenAPI spec includes authentication schemas. I implemented a NoAuthClient that:\nStrips authentication from OpenDota API calls Removes security schemes from the OpenAPI specification Without these changes, the FastMCP solution was not working properly since it expected authentication to be provided and was actually sending invalid headers.\nEncoding Another issue I ran into was with encoding, particularly between MCP-server responses like list_tools and the tools themselves. FastMCP expects UTF-8 strings, but some OpenDota API responses include non-UTF-8 bytes (e.g., in player names). To handle this, I ensured that all responses are properly encoded and decoded as UTF-8, replacing invalid characters as needed.\nMangum To deploy the FastMCP server to AWS Lambda, I used Mangum, an adapter that allows ASGI applications to run on AWS Lambda. This involved wrapping the FastMCP app with Mangum‚Äôs handler, enabling it to process Lambda events and return appropriate HTTP responses. There‚Äôs a somewhat equivalent REST API from AWS Lambda Powertools, but it was easier to use Mangum since FastMCP is ASGI-based.\nAWS CDK The AWS CDK Python Lambda has come a very long way since I last used it. Today, you can use UV to manage your Python dependencies and package them seamlessly for Lambda deployment. All you need is a uv.lock file in your Lambda source directory, and CDK takes care of the rest.\nThere are instructions in the repo on how to deploy the CDK stack to your AWS account for testing and how to configure a tool so that it can call the deployed MCP server via HTTP.\nLessons Learned As mentioned earlier, auto-converting an entire REST API into MCP tools is not ideal for production use. In general a more AI-centric approach is recommended:\nStart with Agent Stories: Identify the key workflows and tasks that agents need to perform. Write down ‚ÄúAs an agent, given {context}, I use {tools} to achieve {outcome}.‚Äù This helps focus on the actual use cases rather than exposing every possible endpoint. Curate Tools: Instead of exposing every endpoint, select and design tools that align with the identified agent stories. This may involve combining multiple API calls into a single tool or simplifying complex endpoints. Optimize for Context: Minimize the number of tools and their complexity to reduce context pollution. Focus on high-value tools that provide the most relevant data for the agent‚Äôs tasks. Don‚Äôt reinvent the wheel: There‚Äôs a lot of new AWS services that can help you build robust MCP servers without starting from scratch. For example AWS AgentCore provides a managed MCP server environment that you can leverage. Conclusion This project demonstrates both the power and the pitfalls of auto-generating MCP servers. FastMCP makes it trivially easy to expose any OpenAPI-compliant API, but that convenience can lead to bloated, inefficient agent interfaces.\nEven so, we were able to successfully build and deploy a serverless MCP server for the OpenDota API using AWS Lambda and API Gateway in a couple of hours. This is exceptional for prototyping and experimentation before you invest in a more curated production solution.\nI used Kiro CLI to interact with the MCP server once deployed. Here‚Äôs an example of querying player statistics using the FastMCP OpenDota MCP server:\nCLI Output ‚úì open-dota loaded in 2.84 s ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚¢Ä‚£¥‚£∂‚£∂‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£∂‚£∂‚£¶‚°Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£∂‚£∂‚£∂‚£∂‚£∂‚£∂‚£∂‚£∂‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£¥‚£∂‚£∂‚£∂‚£∂‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚¢∞‚£ø‚†ã‚†Å‚†à‚†ô‚£ø‚°Ü‚†Ä‚¢Ä‚£æ‚°ø‚†Å‚†Ä‚†à‚¢ª‚°Ü‚¢∞‚£ø‚†ã‚†Å‚†à‚†ô‚£ø‚°Ü‚¢∞‚£ø‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚£¶‚†Ä‚†Ä‚†Ä‚†Ä‚£¥‚°ø‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚¢ø‚£¶‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£á‚£¥‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚†á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚¢†‚£§‚£§‚£§‚£§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°Ü‚†Ä‚†Ä‚£º‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ª‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚°ø‚†Å‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†â‚†â‚†â‚£ø‚°á‚†Ä‚†Ä‚†Ä‚£ø‚°á‚†Ä‚£º‚°ü‚†Ä‚†Ä‚†Ä‚£∞‚°ø‚†ü‚†õ‚†ª‚¢ø‚£Ü‚†Ä‚†Ä‚†Ä‚¢ª‚£ß‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†Å‚†Ä‚†Ä‚¢Ä‚£º‚°ü‚†Å‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£∂‚£∂‚°∂‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚†á‚¢∞‚£ø‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°Ü‚†Ä‚†Ä‚†Ä‚£ø‚°Ü ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£º‚†ü‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚†Ä‚†Ä‚†Ä‚£ø‚°á ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚°Ä‚†Ä‚†Ä‚†π‚£∑‚°Ñ‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚£ø‚°Ö‚†Ä‚†Ä‚†∏‚£ø‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚†á‚†Ä‚†Ä‚†Ä‚£ø‚†á ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚°ü‚£∑‚°Ä‚†Ä‚†Ä‚†ò‚£ø‚£Ü‚†Ä‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ü‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£Ü‚†Ä‚†Ä‚¢ª‚£ß‚†Ä‚†Ä‚†Ä‚†π‚£∑‚£¶‚£§‚£§‚£æ‚†è‚†Ä‚†Ä‚†Ä‚£º‚°ü ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚†π‚£∑‚°Ä‚†Ä‚†Ä‚†à‚¢ª‚°á‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚†π‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚°á‚†Ä‚†Ä‚¢ª‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†â‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚°ü ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†∏‚£ø‚£Ñ‚°Ä‚¢Ä‚£†‚£ø‚†á‚†Ä‚†ô‚£∑‚°Ä‚†Ä‚¢Ä‚£º‚†á‚†Ä‚†∏‚£ø‚£Ñ‚°Ä‚¢Ä‚£†‚£ø‚†á‚†∏‚£ø‚£Ñ‚°Ä‚¢Ä‚£†‚£ø‚†á‚†Ä‚†ô‚£∑‚°Ä‚†Ä‚†Ä‚¢Ä‚£º‚†á‚†Ä‚†Ä‚†Ä‚†ª‚£∑‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£¥‚£æ‚†ü ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†à‚†ª‚†ø‚†ø‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†à‚†ª‚†ø‚†ø‚†ü‚†Å‚†Ä‚†Ä‚†à‚†ª‚†ø‚†ø‚†ü‚†Å‚†Ä‚†Ä‚†à‚†ª‚†ø‚†ø‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†à‚†ª‚†ø‚†ø‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚†ø‚†ø‚†ø‚†ø‚†ü‚†ã‚†Å ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Did you know? ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ ‚îÇ ‚îÇ ‚îÇ You can use /editor to edit your prompt with a vim-like ‚îÇ ‚îÇ experience ‚îÇ ‚îÇ ‚îÇ ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ Model: Auto (/model to change) | Plan: KIRO FREE (/usage for more detail) \u003e I'm thinking what hero to choose given that my team already chose: 1. Axe 2. Winter Wyvern 3. Shadow Fiend 4. Witch Doctor The enemy team chose 1. Juggernaut 2. Primal Beast 3. Queen of Pain 4. Pugna Stop if you run into any MCP server errors and report them. Take your time and use the correct tools, especially those that allow you to see match results based on team comps. You can use delegate or subagents to speed up the process \u003e I'll help you find the best hero pick for your team. Let me analyze the matchups using the available Dota 2 data tools. Running tool get_constants_by_resource with the param (from mcp server: open-dota) ‚ãÆ { ‚ãÆ \"resource\": \"heroes\" ‚ãÆ } Running tool get_find_matches with the param (from mcp server: open-dota) ‚ãÆ { ‚ãÆ \"teamA\": [ ‚ãÆ 1, ‚ãÆ 15, ‚ãÆ 8, ‚ãÆ 79 ‚ãÆ ], ‚ãÆ \"teamB\": [ ‚ãÆ 15, ‚ãÆ 93, ‚ãÆ 101, ‚ãÆ 84 ‚ãÆ ] ‚ãÆ } - Completed in 1.415s - Completed in 0.848s \u003e Let me analyze the matchups for your team composition. I'll check hero matchups against the enemy team to find the best pick. Running tool get_heroes_by_hero_id_select_matchups with the param (from mcp server: open-dota) ‚ãÆ { ‚ãÆ \"hero_id\": 8 ‚ãÆ } Running tool get_heroes_by_hero_id_select_matchups with the param (from mcp server: open-dota) ‚ãÆ { ‚ãÆ \"hero_id\": 112 ‚ãÆ } Running tool get_heroes_by_hero_id_select_matchups with the param (from mcp server: open-dota) ‚ãÆ { ‚ãÆ \"hero_id\": 11 ‚ãÆ } Running tool get_heroes_by_hero_id_select_matchups with the param (from mcp server: open-dota) ‚ãÆ { ‚ãÆ \"hero_id\": 30 ‚ãÆ } - Completed in 0.729s - Completed in 6.61s - Completed in 0.864s - Completed in 4.608s \u003e Based on the matchup data analysis, here are the best hero picks for your team: Top Recommendations: 1. Rubick (Hero ID: 86) - 47.4% win rate vs your enemies - Excellent against Primal Beast, Juggernaut, and Queen of Pain - Provides utility and can steal key enemy abilities - Complements your team's support/control focus 2. Ogre Magi (Hero ID: 84) - 49.3% win rate vs your enemies - Strong against Primal Beast and Juggernaut - Adds tankiness and stun potential - Works well with your existing supports 3. Disruptor (Hero ID: 87) - 52.7% win rate vs your enemies - Excellent against Primal Beast (125 wins in 237 games) - Strong disable against Queen of Pain - Provides good teamfight control 4. Jakiro (Hero ID: 64) - 57% win rate vs your enemies - Very strong matchup overall - Good against Pugna and Queen of Pain - Adds both damage and control Why these work: - Your team has Axe (initiator), Winter Wyvern (support), Shadow Fiend (carry), and Witch Doctor (support) - You need either another support/utility hero or a mid-laner - These picks provide disable/control against Primal Beast's aggression and Queen of Pain's mobility - They synergize well with Winter Wyvern's crowd control Avoid: Pugna is particularly weak against your team composition (only 30 wins in 55 games vs Witch Doctor). I'd recommend Disruptor or Jakiro as your best bets for the strongest matchups against their entire team. ‚ñ∏ Credits: 0.31 ‚Ä¢ Time: 27s I‚Äôm under no illusions that this is even close to Dota Plus, a paid in-game service that provides real-time hero recommendations based on advanced analytics. But it‚Äôs pretty cool to see an AI agent using an MCP server to analyze matchups and suggest hero pick - feel free to use it to let your teammates know who‚Äôs carrying the game üòÅ\nAcknowledgments OpenDota: Free Dota 2 statistics API FastMCP: Powerful MCP server framework rmcp-openapi: Rust OpenAPI to MCP server generator AWS Lambda Powertools: Robust Lambda utilities UV: Next-generation Python package management Jeremiah Lowin: For the important reality check on MCP auto-conversion ","wordCount":"2765","inLanguage":"en","datePublished":"2025-12-24T00:00:00Z","dateModified":"2025-12-24T00:00:00Z","author":{"@type":"Person","name":"Manuel Martinez"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://manmartgarc.github.io/posts/tech-support/fastmcp-opendota/"},"publisher":{"@type":"Organization","name":"Manuel Martinez","logo":{"@type":"ImageObject","url":"https://manmartgarc.github.io/images/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://manmartgarc.github.io/ accesskey=h title="Manuel Martinez (Alt + H)">Manuel Martinez</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://manmartgarc.github.io/about/ title=About><span>About</span></a></li><li><a href=https://manmartgarc.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://manmartgarc.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://manmartgarc.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://manmartgarc.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://manmartgarc.github.io/cv/ title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://manmartgarc.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://manmartgarc.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Building an MCP Server for OpenDota API with FastMCP</h1><div class=post-meta><span title='2025-12-24 00:00:00 +0000 UTC'>December 24, 2025</span>&nbsp;¬∑&nbsp;<span>13 min</span>&nbsp;¬∑&nbsp;<span>Manuel Martinez</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#motivation>Motivation</a><ul><li><a href=#whats-an-mcp-server>What&rsquo;s an MCP server?</a></li><li><a href=#transports>Transports</a></li><li><a href=#but-we-already-have-a-rest-api-at-home>But we already have a REST API (at home)</a></li></ul></li><li><a href=#architecture>Architecture</a><ul><li><a href=#sequence-diagram>Sequence Diagram</a></li><li><a href=#project-structure>Project Structure</a></li></ul></li><li><a href=#is-this-a-good-idea>Is this a good idea?</a></li><li><a href=#implementation>Implementation</a><ul><li><a href=#authentication-removal>Authentication Removal</a></li><li><a href=#encoding>Encoding</a></li><li><a href=#mangum>Mangum</a></li><li><a href=#aws-cdk>AWS CDK</a></li></ul></li><li><a href=#lessons-learned>Lessons Learned</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#acknowledgments>Acknowledgments</a></li></ul></nav></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>You&rsquo;ve probably heard about the <a href=https://modelcontextprotocol.io/docs/getting-started/intro>Model Context Protocol (MCP)</a> by now ‚Äî an emerging standard for connecting AI agents to external data sources and tools.</p><p>I wanted to explore building a serverless HTTP-based MCP server using the typical <a href=https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-api-as-simple-proxy-for-lambda.html>APIGW + Lambda pattern</a> that is common in serverless applications, i.e. the way some MCP server provider might want to host MCP servers for public consumption. When thinking about which tools the MCP server should have, I wondered how hard it would be to convert an existing REST API into an MCP server - especially given some standard specifications like OpenAPI.</p><p>The rest of this post will describe how I built an MCP server for the <a href=https://www.opendota.com/>OpenDota API</a> using FastMCP and deployed it to AWS Lambda + API Gateway and some lessons learned along the way.</p><blockquote><p>If you don&rsquo;t know what <a href=https://www.dota2.com/home>Dota 2</a> is, it&rsquo;s a popular multiplayer online battle arena (MOBA) game where two teams of five players compete to destroy each other&rsquo;s bases. The OpenDota API provides free access to a wealth of Dota 2 statistics, including player data, match histories, hero stats, and more.</p></blockquote><h2 id=motivation>Motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h2><h3 id=whats-an-mcp-server>What&rsquo;s an MCP server?<a hidden class=anchor aria-hidden=true href=#whats-an-mcp-server>#</a></h3><blockquote><p>Throughout this post, I‚Äôll use agent to mean an AI system capable of discovering and invoking MCP tools, and user to mean the human interacting with that agent.</p></blockquote><p>An MCP server is a service that implements the Model Context Protocol (MCP) specification, allowing AI agents to interact with external tools and data sources in a standardized way.
MCP servers expose a unified interface that any compatible agent can use. This is part of the trend of decoupling AI agents from specific API implementations, enabling interoperability across platforms and allowing developers to build once and deploy everywhere and even switch AI backends without rewriting tool integrations.</p><p>Some justifications for MCP servers are:</p><ul><li>Empower LLM-based AI agents with tools that provide real-time data access since it might not be included in their training data. Think of a weather API or stock prices.</li><li>Limiting some of the undefined behavior that comes from the next-token-prediction nature of LLMs by providing structured tool interfaces. For example, arithmetic calculations or database queries.</li><li>Allowing AI agents to leverage specialized external services (e.g., search engines, knowledge bases) that can enhance their capabilities beyond the base LLM. This is especially useful for domain-specific applications or private. For example, an enterprise knowledge base that contains proprietary information not available in public datasets.</li></ul><h3 id=transports>Transports<a hidden class=anchor aria-hidden=true href=#transports>#</a></h3><p>A key part of the MCP specification is the <a href=https://modelcontextprotocol.io/specification/2025-06-18/basic/transports>Transports</a> mechanism, which defines how agents communicate with MCP servers. Initially, the <code>stdio</code> transport was the only option‚Äîagents spawn MCP servers as subprocesses and communicate via standard input/output. However, new mechanisms like HTTP have emerged for remote deployment, allowing MCP servers to be hosted in the cloud and scaled independently.</p><p>For teams building AI tooling at scale, treating MCP servers like standard cloud services‚Äîdeployed, monitored, and scaled with other infrastructure‚Äîmakes sense. HTTP transport is the natural choice here, enabling you to integrate MCP into a larger ecosystem of sessions, authentication, rate limiting, and observability.</p><h3 id=but-we-already-have-a-rest-api-at-home>But we already have a REST API (at home)<a hidden class=anchor aria-hidden=true href=#but-we-already-have-a-rest-api-at-home>#</a></h3><p>There are obviously a trillion existing REST APIs out there - and I wanted to see how easy it would be to convert one of them into an MCP server. Specifically given that there are some API specifications such as OpenAPI that provide machine-readable definitions of REST APIs.</p><p>It turns out there are a couple of options across multiple languages:</p><ul><li><a href=https://crates.io/crates/rmcp-openapi>rmcp-openapi</a>: Can generate MCP servers from OpenAPI specs in Rust</li><li><a href=https://gofastmcp.com/integrations/openapi>fastmcp</a>: A Python framework that can auto-generate MCP servers from OpenAPI specifications</li><li><a href=https://github.com/jedisct1/openapi-mcp>openapi-mcp</a>: A Go library to create MCP servers from OpenAPI specs</li></ul><p>All of these tools do roughly the same thing:</p><ol><li>Parse the OpenAPI specification to extract endpoints, parameters, and schemas.</li><li>Map REST endpoints to MCP tools, converting HTTP methods and paths into tool names and descriptions.</li><li>Generate the necessary MCP server code to handle tool invocations and translate them into REST API calls.</li></ol><p>I tried using <code>rmcp-openapi</code>, but ran into issues with the specification parsing; specifically the <a href=https://swagger.io/docs/specification/v3_0/using-ref/>$ref</a> mechanism. What ended up working was FastMCP&rsquo;s OpenAPI integration, but still required some customizations to handle authentication removal and AWS Lambda deployment as we&rsquo;ll see next.</p><h2 id=architecture>Architecture<a hidden class=anchor aria-hidden=true href=#architecture>#</a></h2><p>The goal is to build an MCP server that exposes the entire OpenDota API without introducing any stateful or long-lived servers, allowing AI agents to query Dota 2 statistics programmatically. The MCP server should be a serverless HTTP service deployed to <a href=https://aws.amazon.com/api-gateway/>APIGW</a> + <a href=https://aws.amazon.com/lambda/>Lambda</a> using <a href=https://aws.amazon.com/cdk/>AWS CDK</a> for infrastructure as code.</p><p>A user can then interact with the MCP server using HTTP requests and any MCP-compatible AI agent.</p><h3 id=sequence-diagram>Sequence Diagram<a hidden class=anchor aria-hidden=true href=#sequence-diagram>#</a></h3><p><a href=https://mermaid.live/edit#pako:eNplkF1rgzAUhv9KOFcb2GKtTpuLgrSbDByWbTAY3pzpmZVpYmOEdqX_fVGxDJqrnOf9OCRnyGROwKGlQ0cio22JhcI6FcycBpUus7JBoVnIsGVhQULfatGg7Z5Z9HErxr0YY_2VI7t7wla_bHb3t7aktyUNia3U2JelYjSFs_U64sykmKLDyCLDYs52Sh5PI4kNSTh7fXx7ZxlW1UiT2WgcsKK2mcz_O9uu0lOt4eGVN2BBococuFYdWVCTqrEf4dz7U9B7qikFbq45qp8UUnExGfOeTynrKaZkV-yBf2PVmqlrctTTN1-pIpGT2shOaOCuN3QAP8MRuOMv5wvHWQZB4Nn2ynUsOAH3HuYPge_6tr_yF8FyFbgXC36HrfY88L3LH5N0jxE><img loading=lazy src="https://mermaid.ink/img/pako:eNplkF1rgzAUhv9KOFcb2GKtTpuLgrSbDByWbTAY3pzpmZVpYmOEdqX_fVGxDJqrnOf9OCRnyGROwKGlQ0cio22JhcI6FcycBpUus7JBoVnIsGVhQULfatGg7Z5Z9HErxr0YY_2VI7t7wla_bHb3t7aktyUNia3U2JelYjSFs_U64sykmKLDyCLDYs52Sh5PI4kNSTh7fXx7ZxlW1UiT2WgcsKK2mcz_O9uu0lOt4eGVN2BBococuFYdWVCTqrEf4dz7U9B7qikFbq45qp8UUnExGfOeTynrKaZkV-yBf2PVmqlrctTTN1-pIpGT2shOaOCuN3QAP8MRuOMv5wvHWQZB4Nn2ynUsOAH3HuYPge_6tr_yF8FyFbgXC36HrfY88L3LH5N0jxE?type=png"></a></p><p>The architecture is very straightforward:</p><ol><li>A Lambda function hosts the FastMCP server that exposes the OpenDota API as MCP tools.</li><li>API Gateway provides an HTTP endpoint that routes requests to the Lambda function.</li><li>AI agents can send HTTP requests to the API Gateway endpoint to invoke MCP tools.</li></ol><p>This project uses:</p><ul><li><strong><a href=https://gofastmcp.com/>FastMCP</a></strong>: Python framework that auto-generates MCP tools from OpenAPI specifications</li><li><strong><a href=https://github.com/jasonthehuman/mangum>Mangum</a></strong>: ASGI adapter for running FastMCP on AWS Lambda</li><li><strong><a href=https://aws.amazon.com/cdk/>AWS CDK</a></strong>: Infrastructure as code for deploying API Gateway + Lambda</li><li><strong><a href=https://github.com/tiangolo/uvicorn>UV</a></strong>: Modern Python package manager for dependency bundling</li><li><strong><a href=https://awslabs.github.io/aws-lambda-powertools-python/latest/>AWS Lambda Powertools</a></strong>: Lambda utilities (though Mangum was preferred for ASGI compatibility)</li></ul><h3 id=project-structure>Project Structure<a hidden class=anchor aria-hidden=true href=#project-structure>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>‚îú‚îÄ‚îÄ lib/ # CDK stack definitions
</span></span><span class=line><span class=cl>‚îú‚îÄ‚îÄ python-lambda/ # Python MCP server code
</span></span><span class=line><span class=cl>‚îÇ ‚îú‚îÄ‚îÄ lambda_function.py # AWS Lambda handler with Mangum adapter
</span></span><span class=line><span class=cl>‚îÇ ‚îú‚îÄ‚îÄ pyproject.toml # Python de    pendencies
</span></span><span class=line><span class=cl>‚îÇ ‚îî‚îÄ‚îÄ uv.lock # Locked dependencies for reproducible builds
</span></span><span class=line><span class=cl>‚îú‚îÄ‚îÄ cdk.json # CDK configuration
</span></span><span class=line><span class=cl>‚îú‚îÄ‚îÄ package.json # Node.js dependencies
</span></span><span class=line><span class=cl>‚îî‚îÄ‚îÄ README.md # Quick start &amp; deployment instructions
</span></span></code></pre></div><h2 id=is-this-a-good-idea>Is this a good idea?<a hidden class=anchor aria-hidden=true href=#is-this-a-good-idea>#</a></h2><p>I want to focus on the discussion around whether this automatic conversion from OpenAPI to MCP tools is a good idea in practice. Feel free to skip my meandering thoughts and jump to the <a href=/posts/tech-support/fastmcp-opendota/#implementation-details>implementation details</a> if you just want to see how it was built.</p><p>There&rsquo;s a <a href=https://www.jlowin.dev/blog/stop-converting-rest-apis-to-mcp>good write-up</a> by <a href=https://www.jlowin.dev/about>Jeremiah Lowin</a>, the creator of FastMCP, on why this approach can be problematic in practice. The gist of it is that while automatic conversion is convenient, it often leads to bloated and inefficient agent interfaces that are hard to use effectively. Definitely recommend reading his post for a deeper dive into this topic - I&rsquo;ll just summarize a few key points here:</p><ol><li><p><strong>Purpose</strong>: REST APIs often have dozens or hundreds of endpoints. These are designed to be consumed by applications with specific use cases in mind. In contrast, MCP tools are intended to be more general-purpose and composable, allowing for greater flexibility in how they are used. Probably the main issue here is that OpenAPI specs are written for humans and lack the <em>semantic clarity</em>, i.e. natural language context, that explains <em>why</em> a tool should be used and not just <em>how</em> to use it.</p></li><li><p><strong>Context</strong>: Each MCP tool that&rsquo;s available to an AI agent adds to the context window that the agent needs to consider when making decisions, i.e. the mechanism through which an agent can discover and invoke tools is by their descriptions being included in the prompt context. The main concern here is that each MCP server and its tools is eating up precious context. Additionally, ff you have too many tools, the agent may struggle to identify the most relevant ones for a given task - think of overlapping descriptions, i.e. some tools may have very similar names or functionalities, making it hard for the agent to choose the right one. This can lead to confusion and suboptimal tool usage.</p></li><li><p><strong>Cycle Length</strong>: REST APIs response times are usually in the order of tens to hundreds of milliseconds. It&rsquo;s common to fire off multiple API calls in quick succession to gather data. However, each MCP tool invocation involves additional overhead because even finding which tool to call requires an inference step based on the tool metadata. Then once the tool is selected, the agent has to generate a new prompt that includes the tool call, send it to the MCP server, wait for the response, and then process the result - which is another inference step. This adds significant latency compared to direct API calls. In practice, each MCP tool invocation can be orders of magnitude slower than a direct API call. If an agent has to make many tool calls to accomplish a task, the overall latency can become prohibitive.</p></li></ol><p>So is it a good idea to auto-convert REST APIs to MCP tools and call it a day? No. Is it a good way to quickly prototype an MCP server and experiment with agent interactions? Absolutely. Just be aware of the limitations and be prepared to refine the tool set for production use. Most OpenAPI to MCP parsers allow you to customize which endpoints get included as tools, so you can easily curate a more focused tool set right off the bat - although this is not a substitute for thoughtful tool design.</p><h2 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><p>Overall the implementation is fairly straightforward thanks to FastMCP&rsquo;s OpenAPI integration and <a href=https://github.com/Kludex/mangum>Mangum</a> for ASGI compatibility with AWS Lambda.</p><p>Take a look at the <a href="https://github.com/manmartgarc/opendotamcp/tree/main?tab=readme-ov-file#-quick-start">full source code</a> for this project on GitHub.</p><h3 id=authentication-removal>Authentication Removal<a hidden class=anchor aria-hidden=true href=#authentication-removal>#</a></h3><p>One challenge was that the OpenDota API supports both public and authenticated endpoints. The public API is accessible without authentication, but the OpenAPI spec includes authentication schemas. I implemented a <a href=https://github.com/manmartgarc/opendotamcp/blob/main/python-lambda/lambda_function.py#L9><code>NoAuthClient</code></a> that:</p><ul><li>Strips authentication from OpenDota API calls</li><li>Removes security schemes from the OpenAPI specification</li></ul><p>Without these changes, the FastMCP solution was not working properly since it expected authentication to be provided and was actually sending invalid headers.</p><h3 id=encoding>Encoding<a hidden class=anchor aria-hidden=true href=#encoding>#</a></h3><p>Another issue I ran into was with encoding, particularly between MCP-server responses like <code>list_tools</code> and the tools themselves. FastMCP expects UTF-8 strings, but some OpenDota API responses include non-UTF-8 bytes (e.g., in player names). To handle this, I ensured that all responses are properly encoded and decoded as UTF-8, replacing invalid characters as needed.</p><h3 id=mangum>Mangum<a hidden class=anchor aria-hidden=true href=#mangum>#</a></h3><p>To deploy the FastMCP server to AWS Lambda, I used <a href=https://github.com/Kludex/mangum>Mangum</a>, an adapter that allows <a href=https://asgi.readthedocs.io/en/latest/>ASGI</a> applications to run on AWS Lambda. This involved wrapping the FastMCP app with Mangum&rsquo;s handler, enabling it to process Lambda events and return appropriate HTTP responses. There&rsquo;s a somewhat equivalent <a href=https://docs.aws.amazon.com/powertools/python/latest/core/event_handler/api_gateway/>REST API</a> from AWS Lambda Powertools, but it was easier to use Mangum since FastMCP is ASGI-based.</p><h3 id=aws-cdk>AWS CDK<a hidden class=anchor aria-hidden=true href=#aws-cdk>#</a></h3><p>The <a href=https://docs.aws.amazon.com/cdk/api/v2/docs/aws-lambda-python-alpha-readme.html#packaging>AWS CDK Python Lambda</a> has come a very long way since I last used it. Today, you can use <a href=https://docs.astral.sh/uv/>UV</a> to manage your Python dependencies and package them seamlessly for Lambda deployment. All you need is a <code>uv.lock</code> file in your Lambda source directory, and CDK takes care of the rest.</p><p>There are instructions in the <a href=https://github.com/manmartgarc/opendotamcp/tree/main>repo</a> on how to deploy the CDK stack to your AWS account for testing and how to configure a tool so that it can call the deployed MCP server via HTTP.</p><h2 id=lessons-learned>Lessons Learned<a hidden class=anchor aria-hidden=true href=#lessons-learned>#</a></h2><p>As mentioned earlier, auto-converting an entire REST API into MCP tools is not ideal for production use. In general a more AI-centric approach is recommended:</p><ol><li><strong>Start with Agent Stories</strong>: Identify the key workflows and tasks that agents need to perform. Write down &ldquo;As an agent, given {context}, I use {tools} to achieve {outcome}.&rdquo; This helps focus on the actual use cases rather than exposing every possible endpoint.</li><li><strong>Curate Tools</strong>: Instead of exposing every endpoint, select and design tools that align with the identified agent stories. This may involve combining multiple API calls into a single tool or simplifying complex endpoints.</li><li><strong>Optimize for Context</strong>: Minimize the number of tools and their complexity to reduce context pollution. Focus on high-value tools that provide the most relevant data for the agent&rsquo;s tasks.</li><li><strong>Don&rsquo;t reinvent the wheel</strong>: There&rsquo;s a lot of new AWS services that can help you build robust MCP servers without starting from scratch. For example <a href=https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-mcp.html>AWS AgentCore</a> provides a managed MCP server environment that you can leverage.</li></ol><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This project demonstrates both the power and the pitfalls of auto-generating MCP servers. FastMCP makes it trivially easy to expose any OpenAPI-compliant API, but that convenience can lead to bloated, inefficient agent interfaces.</p><p>Even so, we were able to successfully build and deploy a serverless MCP server for the OpenDota API using AWS Lambda and API Gateway in a couple of hours. This is exceptional for prototyping and experimentation before you invest in a more curated production solution.</p><p>I used <a href=https://kiro.dev/cli/>Kiro CLI</a> to interact with the MCP server once deployed. Here&rsquo;s an example of querying player statistics using the FastMCP OpenDota MCP server:</p><details><summary>CLI Output</summary><div class=expand-content><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>‚úì open-dota loaded in 2.84 s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
</span></span><span class=line><span class=cl>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä     ‚¢Ä‚£¥‚£∂‚£∂‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£∂‚£∂‚£¶‚°Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£∂‚£∂‚£∂‚£∂‚£∂‚£∂‚£∂‚£∂‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£¥‚£∂‚£∂‚£∂‚£∂‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
</span></span><span class=line><span class=cl>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä    ‚¢∞‚£ø‚†ã‚†Å‚†à‚†ô‚£ø‚°Ü‚†Ä‚¢Ä‚£æ‚°ø‚†Å‚†Ä‚†à‚¢ª‚°Ü‚¢∞‚£ø‚†ã‚†Å‚†à‚†ô‚£ø‚°Ü‚¢∞‚£ø‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚£¶‚†Ä‚†Ä‚†Ä‚†Ä‚£¥‚°ø‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚¢ø‚£¶‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
</span></span><span class=line><span class=cl>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä    ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£á‚£¥‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚†á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚¢†‚£§‚£§‚£§‚£§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°Ü‚†Ä‚†Ä‚£º‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ª‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
</span></span><span class=line><span class=cl>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä    ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚°ø‚†Å‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†â‚†â‚†â‚£ø‚°á‚†Ä‚†Ä‚†Ä‚£ø‚°á‚†Ä‚£º‚°ü‚†Ä‚†Ä‚†Ä‚£∞‚°ø‚†ü‚†õ‚†ª‚¢ø‚£Ü‚†Ä‚†Ä‚†Ä‚¢ª‚£ß‚†Ä‚†Ä‚†Ä‚†Ä
</span></span><span class=line><span class=cl>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä    ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†Å‚†Ä‚†Ä‚¢Ä‚£º‚°ü‚†Å‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£∂‚£∂‚°∂‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚†á‚¢∞‚£ø‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°Ü‚†Ä‚†Ä‚†Ä‚£ø‚°Ü
</span></span><span class=line><span class=cl>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä    ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£º‚†ü‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚†Ä‚†Ä‚†Ä‚£ø‚°á
</span></span><span class=line><span class=cl>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä    ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚°Ä‚†Ä‚†Ä‚†π‚£∑‚°Ñ‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚£ø‚°Ö‚†Ä‚†Ä‚†∏‚£ø‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚†á‚†Ä‚†Ä‚†Ä‚£ø‚†á
</span></span><span class=line><span class=cl>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä    ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚°ü‚£∑‚°Ä‚†Ä‚†Ä‚†ò‚£ø‚£Ü‚†Ä‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ü‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£Ü‚†Ä‚†Ä‚¢ª‚£ß‚†Ä‚†Ä‚†Ä‚†π‚£∑‚£¶‚£§‚£§‚£æ‚†è‚†Ä‚†Ä‚†Ä‚£º‚°ü
</span></span><span class=line><span class=cl>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä    ‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚†π‚£∑‚°Ä‚†Ä‚†Ä‚†à‚¢ª‚°á‚†Ä‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°á‚†π‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚°á‚†Ä‚†Ä‚¢ª‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†â‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚°ü
</span></span><span class=line><span class=cl>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä    ‚†∏‚£ø‚£Ñ‚°Ä‚¢Ä‚£†‚£ø‚†á‚†Ä‚†ô‚£∑‚°Ä‚†Ä‚¢Ä‚£º‚†á‚†Ä‚†∏‚£ø‚£Ñ‚°Ä‚¢Ä‚£†‚£ø‚†á‚†∏‚£ø‚£Ñ‚°Ä‚¢Ä‚£†‚£ø‚†á‚†Ä‚†ô‚£∑‚°Ä‚†Ä‚†Ä‚¢Ä‚£º‚†á‚†Ä‚†Ä‚†Ä‚†ª‚£∑‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£¥‚£æ‚†ü
</span></span><span class=line><span class=cl>‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä    ‚†Ä‚†à‚†ª‚†ø‚†ø‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†à‚†ª‚†ø‚†ø‚†ü‚†Å‚†Ä‚†Ä‚†à‚†ª‚†ø‚†ø‚†ü‚†Å‚†Ä‚†Ä‚†à‚†ª‚†ø‚†ø‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†à‚†ª‚†ø‚†ø‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚†ø‚†ø‚†ø‚†ø‚†ü‚†ã‚†Å
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Did you know? ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
</span></span><span class=line><span class=cl>‚îÇ                                                                              ‚îÇ
</span></span><span class=line><span class=cl>‚îÇ           You can use /editor to edit your prompt with a vim-like            ‚îÇ
</span></span><span class=line><span class=cl>‚îÇ                                  experience                                  ‚îÇ
</span></span><span class=line><span class=cl>‚îÇ                                                                              ‚îÇ
</span></span><span class=line><span class=cl>‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Model: Auto (/model to change) | Plan: KIRO FREE (/usage for more detail)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&gt; I&#39;m thinking what hero to choose given that my team already chose:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1. Axe
</span></span><span class=line><span class=cl>2. Winter Wyvern
</span></span><span class=line><span class=cl>3. Shadow Fiend
</span></span><span class=line><span class=cl>4. Witch Doctor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The enemy team chose
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1. Juggernaut
</span></span><span class=line><span class=cl>2. Primal Beast
</span></span><span class=line><span class=cl>3. Queen of Pain
</span></span><span class=line><span class=cl>4. Pugna
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Stop if you run into any MCP server errors and report them. Take your time and use the correct tools, especially those that allow you to see match results based on team comps. You can use delegate or subagents to speed up the process
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&gt; I&#39;ll help you find the best hero pick for your team. Let me analyze the matchups using the available Dota 2 data tools.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Running tool get_constants_by_resource with the param (from mcp server: open-dota)
</span></span><span class=line><span class=cl> ‚ãÆ  {
</span></span><span class=line><span class=cl> ‚ãÆ    &#34;resource&#34;: &#34;heroes&#34;
</span></span><span class=line><span class=cl> ‚ãÆ  }
</span></span><span class=line><span class=cl>Running tool get_find_matches with the param (from mcp server: open-dota)
</span></span><span class=line><span class=cl> ‚ãÆ  {
</span></span><span class=line><span class=cl> ‚ãÆ    &#34;teamA&#34;: [
</span></span><span class=line><span class=cl> ‚ãÆ      1,
</span></span><span class=line><span class=cl> ‚ãÆ      15,
</span></span><span class=line><span class=cl> ‚ãÆ      8,
</span></span><span class=line><span class=cl> ‚ãÆ      79
</span></span><span class=line><span class=cl> ‚ãÆ    ],
</span></span><span class=line><span class=cl> ‚ãÆ    &#34;teamB&#34;: [
</span></span><span class=line><span class=cl> ‚ãÆ      15,
</span></span><span class=line><span class=cl> ‚ãÆ      93,
</span></span><span class=line><span class=cl> ‚ãÆ      101,
</span></span><span class=line><span class=cl> ‚ãÆ      84
</span></span><span class=line><span class=cl> ‚ãÆ    ]
</span></span><span class=line><span class=cl> ‚ãÆ  }
</span></span><span class=line><span class=cl> - Completed in 1.415s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> - Completed in 0.848s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&gt; Let me analyze the matchups for your team composition. I&#39;ll check hero matchups against the enemy team to find the best pick.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Running tool get_heroes_by_hero_id_select_matchups with the param (from mcp server: open-dota)
</span></span><span class=line><span class=cl> ‚ãÆ  {
</span></span><span class=line><span class=cl> ‚ãÆ    &#34;hero_id&#34;: 8
</span></span><span class=line><span class=cl> ‚ãÆ  }
</span></span><span class=line><span class=cl>Running tool get_heroes_by_hero_id_select_matchups with the param (from mcp server: open-dota)
</span></span><span class=line><span class=cl> ‚ãÆ  {
</span></span><span class=line><span class=cl> ‚ãÆ    &#34;hero_id&#34;: 112
</span></span><span class=line><span class=cl> ‚ãÆ  }
</span></span><span class=line><span class=cl>Running tool get_heroes_by_hero_id_select_matchups with the param (from mcp server: open-dota)
</span></span><span class=line><span class=cl> ‚ãÆ  {
</span></span><span class=line><span class=cl> ‚ãÆ    &#34;hero_id&#34;: 11
</span></span><span class=line><span class=cl> ‚ãÆ  }
</span></span><span class=line><span class=cl>Running tool get_heroes_by_hero_id_select_matchups with the param (from mcp server: open-dota)
</span></span><span class=line><span class=cl> ‚ãÆ  {
</span></span><span class=line><span class=cl> ‚ãÆ    &#34;hero_id&#34;: 30
</span></span><span class=line><span class=cl> ‚ãÆ  }
</span></span><span class=line><span class=cl> - Completed in 0.729s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> - Completed in 6.61s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> - Completed in 0.864s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> - Completed in 4.608s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&gt; Based on the matchup data analysis, here are the best hero picks for your team:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Top Recommendations:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1. Rubick (Hero ID: 86) - 47.4% win rate vs your enemies
</span></span><span class=line><span class=cl>   - Excellent against Primal Beast, Juggernaut, and Queen of Pain
</span></span><span class=line><span class=cl>   - Provides utility and can steal key enemy abilities
</span></span><span class=line><span class=cl>   - Complements your team&#39;s support/control focus
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>2. Ogre Magi (Hero ID: 84) - 49.3% win rate vs your enemies
</span></span><span class=line><span class=cl>   - Strong against Primal Beast and Juggernaut
</span></span><span class=line><span class=cl>   - Adds tankiness and stun potential
</span></span><span class=line><span class=cl>   - Works well with your existing supports
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>3. Disruptor (Hero ID: 87) - 52.7% win rate vs your enemies
</span></span><span class=line><span class=cl>   - Excellent against Primal Beast (125 wins in 237 games)
</span></span><span class=line><span class=cl>   - Strong disable against Queen of Pain
</span></span><span class=line><span class=cl>   - Provides good teamfight control
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>4. Jakiro (Hero ID: 64) - 57% win rate vs your enemies
</span></span><span class=line><span class=cl>   - Very strong matchup overall
</span></span><span class=line><span class=cl>   - Good against Pugna and Queen of Pain
</span></span><span class=line><span class=cl>   - Adds both damage and control
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Why these work:
</span></span><span class=line><span class=cl>- Your team has Axe (initiator), Winter Wyvern (support), Shadow Fiend (carry), and Witch Doctor (support)
</span></span><span class=line><span class=cl>- You need either another support/utility hero or a mid-laner
</span></span><span class=line><span class=cl>- These picks provide disable/control against Primal Beast&#39;s aggression and Queen of Pain&#39;s mobility
</span></span><span class=line><span class=cl>- They synergize well with Winter Wyvern&#39;s crowd control
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Avoid: Pugna is particularly weak against your team composition (only 30 wins in 55 games vs Witch Doctor).
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>I&#39;d recommend Disruptor or Jakiro as your best bets for the strongest matchups against their entire team.
</span></span><span class=line><span class=cl> ‚ñ∏ Credits: 0.31 ‚Ä¢ Time: 27s
</span></span></code></pre></div></div></details><p>I&rsquo;m under no illusions that this is even close to <a href=https://www.dota2.com/plus>Dota Plus</a>, a paid in-game service that provides real-time hero recommendations based on advanced analytics. But it&rsquo;s pretty cool to see an AI agent using an MCP server to analyze matchups and suggest hero pick - feel free to use it to let your teammates know who&rsquo;s carrying the game &#x1f601;</p><h2 id=acknowledgments>Acknowledgments<a hidden class=anchor aria-hidden=true href=#acknowledgments>#</a></h2><ul><li><a href=https://www.opendota.com/>OpenDota</a>: Free Dota 2 statistics API</li><li><a href=https://gofastmcp.com/>FastMCP</a>: Powerful MCP server framework</li><li><a href=https://gitlab.com/lx-industries/rmcp-openapi/-/tree/main/crates/rmcp-openapi-server>rmcp-openapi</a>: Rust OpenAPI to MCP server generator</li><li><a href=https://awslabs.github.io/aws-lambda-powertools-python/>AWS Lambda Powertools</a>: Robust Lambda utilities</li><li><a href=https://docs.astral.sh/uv/>UV</a>: Next-generation Python package management</li><li><a href=https://www.jlowin.dev/>Jeremiah Lowin</a>: For the important reality check on MCP auto-conversion</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://manmartgarc.github.io/tags/aws/>Aws</a></li><li><a href=https://manmartgarc.github.io/tags/python/>Python</a></li><li><a href=https://manmartgarc.github.io/tags/cdk/>Cdk</a></li><li><a href=https://manmartgarc.github.io/tags/mcp/>Mcp</a></li></ul><nav class=paginav><a class=prev href=https://manmartgarc.github.io/posts/tech-support/rust-lambda/><span class=title>¬´ Prev</span><br><span>Lambda Functions with Rust and CDK</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://manmartgarc.github.io/>Manuel Martinez</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>