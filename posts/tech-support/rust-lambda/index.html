<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lambda Functions with Rust and CDK | Manuel Martinez</title><meta name=keywords content="aws,cloud,rust,cdk"><meta name=description content="Introduction
This post is a follow-up to the previous post on Lambda Functions with Go and CDK. In this post, we&rsquo;ll go through deploying a Rust-based AWS Lambda function using the AWS Cloud Development Kit (CDK). We&rsquo;ll focus on the developer workflow: how to get started, wire up your Rust Lambda, and use CDK to manage your infrastructure as code. If you&rsquo;re already familiar with Lambda as a service, this guide will help you get productive with Rust and CDK quickly."><meta name=author content="Manuel Martinez"><link rel=canonical href=https://manmartgarc.github.io/posts/tech-support/rust-lambda/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://manmartgarc.github.io/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://manmartgarc.github.io/images/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://manmartgarc.github.io/images/favicon.ico><link rel=apple-touch-icon href=https://manmartgarc.github.io/apple-touch-icon.png><link rel=mask-icon href=https://manmartgarc.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://manmartgarc.github.io/posts/tech-support/rust-lambda/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://manmartgarc.github.io/posts/tech-support/rust-lambda/"><meta property="og:site_name" content="Manuel Martinez"><meta property="og:title" content="Lambda Functions with Rust and CDK"><meta property="og:description" content="Introduction This post is a follow-up to the previous post on Lambda Functions with Go and CDK. In this post, weâ€™ll go through deploying a Rust-based AWS Lambda function using the AWS Cloud Development Kit (CDK). Weâ€™ll focus on the developer workflow: how to get started, wire up your Rust Lambda, and use CDK to manage your infrastructure as code. If youâ€™re already familiar with Lambda as a service, this guide will help you get productive with Rust and CDK quickly."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-27T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-27T00:00:00+00:00"><meta property="article:tag" content="Aws"><meta property="article:tag" content="Cloud"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Cdk"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lambda Functions with Rust and CDK"><meta name=twitter:description content="Introduction
This post is a follow-up to the previous post on Lambda Functions with Go and CDK. In this post, we&rsquo;ll go through deploying a Rust-based AWS Lambda function using the AWS Cloud Development Kit (CDK). We&rsquo;ll focus on the developer workflow: how to get started, wire up your Rust Lambda, and use CDK to manage your infrastructure as code. If you&rsquo;re already familiar with Lambda as a service, this guide will help you get productive with Rust and CDK quickly."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://manmartgarc.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Lambda Functions with Rust and CDK","item":"https://manmartgarc.github.io/posts/tech-support/rust-lambda/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lambda Functions with Rust and CDK","name":"Lambda Functions with Rust and CDK","description":"Introduction This post is a follow-up to the previous post on Lambda Functions with Go and CDK. In this post, we\u0026rsquo;ll go through deploying a Rust-based AWS Lambda function using the AWS Cloud Development Kit (CDK). We\u0026rsquo;ll focus on the developer workflow: how to get started, wire up your Rust Lambda, and use CDK to manage your infrastructure as code. If you\u0026rsquo;re already familiar with Lambda as a service, this guide will help you get productive with Rust and CDK quickly.\n","keywords":["aws","cloud","rust","cdk"],"articleBody":"Introduction This post is a follow-up to the previous post on Lambda Functions with Go and CDK. In this post, weâ€™ll go through deploying a Rust-based AWS Lambda function using the AWS Cloud Development Kit (CDK). Weâ€™ll focus on the developer workflow: how to get started, wire up your Rust Lambda, and use CDK to manage your infrastructure as code. If youâ€™re already familiar with Lambda as a service, this guide will help you get productive with Rust and CDK quickly.\nI want to share all the documentation I found useful while writing this post up front, so you can get started quickly. The main resources are:\nAWS Docs: Creating Lambda functions in the AWS SDK for Rust Building Lambda Functions with Rust Unit testing with aws-smithy-mocks in the AWS SDK for Rust Code Packages: Rust Runtime for AWS Lambda @cdklabs/aws-lambda-rust Rust SDK for AWS Examples Cargo Lambda Why Rust? Rust is a modern, memory-safe, and high-performance language. For Lambda functions, Rust offers fast cold starts and low memory overhead, making it a great fit for event-driven workloads with high volume and low latency. With the growing ecosystem around cargo-lambda and the @cdklabs/aws-lambda-rust CDK construct, deploying Rust Lambdas is getting easier every day.\nProject Structure Weâ€™ll use a monorepo layout, with the CDK app (TypeScript) and the Rust Lambda function side by side:\nmy-cdk-rust-lambda/ â”œâ”€â”€ rust_lambda/ # Rust Lambda function â”‚ â”œâ”€â”€ src/ â”‚ â”œâ”€â”€ Cargo.toml â”‚ â””â”€â”€ ... â”œâ”€â”€ lib/ â”‚ â””â”€â”€ lambda-rust-stack.ts # CDK stack definition â”œâ”€â”€ bin/ â”‚ â””â”€â”€ lambda-rust.ts # CDK app entrypoint â”œâ”€â”€ package.json â”œâ”€â”€ cdk.json â””â”€â”€ ... Setting Up the CDK Project Start by making sure you have the AWS CDK CLI installed. If you donâ€™t have it yet, you can install it globally with:\nnpm install -g aws-cdk You also need to install cargo lambda to easily create the Rust package for your Lambda function.\nInitialize a new CDK project:\nmkdir my-cdk-rust-lambda \u0026\u0026 cd my-cdk-rust-lambda cdk init app --language typescript npm install @cdklabs/aws-lambda-rust aws-cdk-lib constructs Add your Rust Lambda code:\ncargo lambda new rust_lambda # Write your Lambda logic in rust_lambda/src/main.rs Defining the Stack Hereâ€™s a minimal CDK stack that deploys a Rust Lambda and an S3 bucket, wiring the bucket to trigger the Lambda on object creation:\nimport * as rust from '@cdklabs/aws-lambda-rust'; import * as cdk from 'aws-cdk-lib'; import * as s3 from 'aws-cdk-lib/aws-s3'; import * as s3events from 'aws-cdk-lib/aws-s3-notifications'; import { Construct } from 'constructs'; export class LambdaRustStack extends cdk.Stack { private readonly rustHandler: rust.RustFunction; private readonly bucket: s3.Bucket; constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); this.bucket = new s3.Bucket(this, 'HelloRustBucket', { enforceSSL: true, removalPolicy: cdk.RemovalPolicy.DESTROY, autoDeleteObjects: true }); this.rustHandler = new rust.RustFunction(this, 'HelloRust', { binaryName: 'rust_lambda', entry: 'rust_lambda' }); this.bucket.grantReadWrite(this.rustHandler); this.bucket.addEventNotification(s3.EventType.OBJECT_CREATED, new s3events.LambdaDestination(this.rustHandler)); } } Whenever an object is created in the S3 bucket, the Rust Lambda function will be triggered, and its invocation event will contain a standard S3 event structure. We plan to implement a Lambda that processes the S3 event, for example, by deleting the object after processing it.\nWriting the Rust Lambda Our Rust Lambda can use the lambda_runtime and aws-sdk-s3 crates. Hereâ€™s a simplified example:\nuse aws_config::BehaviorVersion; use aws_sdk_s3::Client as S3Client; use lambda_runtime::{run, service_fn, tracing, Error}; mod event_handler; use event_handler::function_handler; #[tokio::main] async fn main() -\u003e Result\u003c(), Error\u003e { tracing::subscriber::fmt().json().init(); let shared_config = aws_config::load_defaults(BehaviorVersion::v2025_01_17()).await; let s3_client = S3Client::new(\u0026shared_config); run(service_fn(|event| function_handler(event, \u0026s3_client))).await } Letâ€™s break this down:\nThe lambda_runtime crate provides a couple of things: run, which is the main entry point for our Lambda function, and service_fn, which allows us to define a handler function that will be called with the event data. The tracing crate is used for logging and more, and we initialize it to output JSON logs. The aws_config crate provides implementations of region and credential resolution, which are used throughout the AWS SDK for Rust. The aws_sdk_s3 crate provides the S3 client that we use to interact with S3. Similarly, if we wanted to use DynamoDB, we would use the aws_sdk_dynamodb crate. Notice that we are using tokio, which is an asynchronous runtime for Rust. This allows the main() method to use async/await syntax, which is very useful for I/O-bound tasks like network requests. Finally, some variables are initialized in the main() method, such as shared_config and s3_client. These variables are shared across Lambda invocations because theyâ€™re part of the init phase. This is where we want to put our expensive initialization code, as it avoids re-initializing the S3 client on every invocation. The event_handler module contains the logic for processing S3 events and deleting objects. You can see its full implementation in GitHub â€” but itâ€™s not very complex; it just extracts the bucket name and object key from the S3 event and deletes the object using the S3 client.\nBuilding and Deploying If you just want to test the Rust code, you can run\ncargo test In Rust, the convention is to put the unit tests in the same file as the code, inside a #[cfg(test)] module. This means that you can run cargo test to run all the tests in your project, including the ones in the event_handler.rs module.\nLocal Lambda Testing You can test your Lambda locally using cargo-lambda:\ncargo lambda watch # In another terminal: cargo lambda invoke -F s3-example.json Keep in mind that since the Lambda is triggered by S3 events, you will need to provide a valid S3 event payload when invoking the Lambda locally. The --data-example s3-put flag provides a sample S3 PUT event.\nWhen we are happy with our Rust code, we can build the Lambda binary and deploy it using CDK:\ncdk deploy The @cdklabs/aws-lambda-rust CDK construct will handle packaging the Rust binary (using a Docker image with the Rust toolchain) and deploying the stack. The cdk deploy command will also create the S3 bucket and wire it up to the Lambda function. Now you can upload files to the S3 bucket, and the Lambda function will be triggered automatically â€” you can check the logs in CloudWatch to see the Lambda function processing the S3 events and also deleting the objects after processing them.\nArchitecture Before we finish, I want to talk a little about the architecture of our CDK stack â€” specifically about using S3 events directly to trigger the Lambda function.\nThis is fine for a simple use case, like this one, where we just want to process S3 events and delete the objects. However, the main drawback of this approach is that any events that fail to be processed by the Lambda function will be lost. This is a serious issue, because everything breaks all the time in production.\nA better approach is to use an SQS queue as an intermediary between the S3 bucket and the Lambda function. This way, we can gracefully handle two main failure modes:\nEvents that are unable to be processed by the Lambda function (e.g., malformed events, or events that the Lambda function cannot handle). We can report back batch item failures to SQS, so that even though the Lambda function succeeds, the events are sent back to the SQS queue for reprocessing later. If an event is sent back a certain number of times, we can send it to a dead-letter queue (DLQ) for further investigation. Events that are not processed by the Lambda function due to a transient error (e.g., network issues, or the Lambda function being throttled). In this case, the SQS queue will automatically retry the event because we donâ€™t delete the message from the queue until the Lambda function successfully processes it. This means that we can handle transient errors gracefully, without losing any events. This retry mechanism is built into integrations between SQS and Lambda, so you donâ€™t have to implement it yourself. You can also use the AWS SDK for Rust to send messages to the SQS queue from your Rust Lambda function, if you need to.\nConclusion With AWS CDK and the Rust Lambda ecosystem, you can quickly get started building high-performance serverless applications. The developer workflow is smooth: write your Lambda in Rust, define your infrastructure in TypeScript, and let CDK handle the rest!\nðŸ¦€ Happy building ðŸ¦€\n","wordCount":"1359","inLanguage":"en","datePublished":"2025-07-27T00:00:00Z","dateModified":"2025-07-27T00:00:00Z","author":{"@type":"Person","name":"Manuel Martinez"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://manmartgarc.github.io/posts/tech-support/rust-lambda/"},"publisher":{"@type":"Organization","name":"Manuel Martinez","logo":{"@type":"ImageObject","url":"https://manmartgarc.github.io/images/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://manmartgarc.github.io/ accesskey=h title="Manuel Martinez (Alt + H)">Manuel Martinez</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://manmartgarc.github.io/about/ title=About><span>About</span></a></li><li><a href=https://manmartgarc.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://manmartgarc.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://manmartgarc.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://manmartgarc.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://manmartgarc.github.io/cv/ title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://manmartgarc.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://manmartgarc.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Lambda Functions with Rust and CDK</h1><div class=post-meta><span title='2025-07-27 00:00:00 +0000 UTC'>July 27, 2025</span>&nbsp;Â·&nbsp;<span>7 min</span>&nbsp;Â·&nbsp;<span>Manuel Martinez</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#why-rust>Why Rust?</a></li><li><a href=#project-structure>Project Structure</a></li><li><a href=#setting-up-the-cdk-project>Setting Up the CDK Project</a></li><li><a href=#defining-the-stack>Defining the Stack</a></li><li><a href=#writing-the-rust-lambda>Writing the Rust Lambda</a></li><li><a href=#building-and-deploying>Building and Deploying</a><ul><li><a href=#local-lambda-testing>Local Lambda Testing</a></li></ul></li><li><a href=#architecture>Architecture</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>This post is a follow-up to the previous post on <a href=/posts/tech-support/go-lambda/>Lambda Functions with Go and CDK</a>. In this post, we&rsquo;ll go through deploying a Rust-based AWS Lambda function using the AWS Cloud Development Kit (CDK). We&rsquo;ll focus on the developer workflow: how to get started, wire up your Rust Lambda, and use CDK to manage your infrastructure as code. If you&rsquo;re already familiar with Lambda as a service, this guide will help you get productive with Rust and CDK quickly.</p><p>I want to share all the documentation I found useful while writing this post up front, so you can get started quickly. The main resources are:</p><ul><li><strong>AWS Docs</strong>:<ol><li><a href=https://docs.aws.amazon.com/sdk-for-rust/latest/dg/lambda.html>Creating Lambda functions in the AWS SDK for Rust</a></li><li><a href=https://docs.aws.amazon.com/lambda/latest/dg/lambda-rust.html>Building Lambda Functions with Rust</a></li><li><a href=https://docs.aws.amazon.com/sdk-for-rust/latest/dg/testing-smithy-mocks.html>Unit testing with aws-smithy-mocks in the AWS SDK for Rust</a></li></ol></li><li><strong>Code Packages</strong>:<ol><li><a href=https://github.com/awslabs/aws-lambda-rust-runtime>Rust Runtime for AWS Lambda</a></li><li><a href=https://github.com/cdklabs/aws-lambda-rust>@cdklabs/aws-lambda-rust</a></li><li><a href=https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/rustv1>Rust SDK for AWS Examples</a></li><li><a href=https://www.cargo-lambda.info/>Cargo Lambda</a></li></ol></li></ul><h2 id=why-rust>Why Rust?<a hidden class=anchor aria-hidden=true href=#why-rust>#</a></h2><p>Rust is a modern, memory-safe, and high-performance language. For Lambda functions, Rust offers <a href=https://maxday.github.io/lambda-perf/>fast cold starts and low memory overhead</a>, making it a great fit for event-driven workloads with high volume and low latency. With the growing ecosystem around <a href=https://www.cargo-lambda.info/>cargo-lambda</a> and the <a href=https://github.com/cdklabs/aws-lambda-rust>@cdklabs/aws-lambda-rust</a> CDK construct, deploying Rust Lambdas is getting easier every day.</p><h2 id=project-structure>Project Structure<a hidden class=anchor aria-hidden=true href=#project-structure>#</a></h2><p>We&rsquo;ll use a monorepo layout, with the CDK app (TypeScript) and the Rust Lambda function side by side:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>my-cdk-rust-lambda/
</span></span><span class=line><span class=cl>â”œâ”€â”€ rust_lambda/              # Rust Lambda function
</span></span><span class=line><span class=cl>â”‚   â”œâ”€â”€ src/
</span></span><span class=line><span class=cl>â”‚   â”œâ”€â”€ Cargo.toml
</span></span><span class=line><span class=cl>â”‚   â””â”€â”€ ...
</span></span><span class=line><span class=cl>â”œâ”€â”€ lib/
</span></span><span class=line><span class=cl>â”‚   â””â”€â”€ lambda-rust-stack.ts  # CDK stack definition
</span></span><span class=line><span class=cl>â”œâ”€â”€ bin/
</span></span><span class=line><span class=cl>â”‚   â””â”€â”€ lambda-rust.ts        # CDK app entrypoint
</span></span><span class=line><span class=cl>â”œâ”€â”€ package.json
</span></span><span class=line><span class=cl>â”œâ”€â”€ cdk.json
</span></span><span class=line><span class=cl>â””â”€â”€ ...
</span></span></code></pre></div><h2 id=setting-up-the-cdk-project>Setting Up the CDK Project<a hidden class=anchor aria-hidden=true href=#setting-up-the-cdk-project>#</a></h2><p>Start by making sure you have the AWS CDK CLI installed. If you don&rsquo;t have it yet, you can install it globally with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>npm install -g aws-cdk
</span></span></code></pre></div><p>You also need to <a href=https://www.cargo-lambda.info/guide/installation.html>install cargo lambda</a> to easily create the Rust package for your Lambda function.</p><ol><li><p><strong>Initialize a new CDK project:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir my-cdk-rust-lambda <span class=o>&amp;&amp;</span> <span class=nb>cd</span> my-cdk-rust-lambda
</span></span><span class=line><span class=cl>cdk init app --language typescript
</span></span><span class=line><span class=cl>npm install @cdklabs/aws-lambda-rust aws-cdk-lib constructs
</span></span></code></pre></div></li><li><p><strong>Add your Rust Lambda code:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cargo lambda new rust_lambda
</span></span><span class=line><span class=cl><span class=c1># Write your Lambda logic in rust_lambda/src/main.rs</span>
</span></span></code></pre></div></li></ol><h2 id=defining-the-stack>Defining the Stack<a hidden class=anchor aria-hidden=true href=#defining-the-stack>#</a></h2><p>Here&rsquo;s a minimal CDK stack that deploys a Rust Lambda and an S3 bucket, wiring the bucket to trigger the Lambda on object creation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>import</span> <span class=o>*</span> <span class=kr>as</span> <span class=nx>rust</span> <span class=kr>from</span> <span class=s1>&#39;@cdklabs/aws-lambda-rust&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=o>*</span> <span class=kr>as</span> <span class=nx>cdk</span> <span class=kr>from</span> <span class=s1>&#39;aws-cdk-lib&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=o>*</span> <span class=kr>as</span> <span class=nx>s3</span> <span class=kr>from</span> <span class=s1>&#39;aws-cdk-lib/aws-s3&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=o>*</span> <span class=kr>as</span> <span class=nx>s3events</span> <span class=kr>from</span> <span class=s1>&#39;aws-cdk-lib/aws-s3-notifications&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>Construct</span> <span class=p>}</span> <span class=kr>from</span> <span class=s1>&#39;constructs&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=kr>class</span> <span class=nx>LambdaRustStack</span> <span class=kr>extends</span> <span class=nx>cdk</span><span class=p>.</span><span class=nx>Stack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>private</span> <span class=kr>readonly</span> <span class=nx>rustHandler</span>: <span class=kt>rust.RustFunction</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kr>private</span> <span class=kr>readonly</span> <span class=nx>bucket</span>: <span class=kt>s3.Bucket</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kr>constructor</span><span class=p>(</span><span class=nx>scope</span>: <span class=kt>Construct</span><span class=p>,</span> <span class=nx>id</span>: <span class=kt>string</span><span class=p>,</span> <span class=nx>props?</span>: <span class=kt>cdk.StackProps</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>super</span><span class=p>(</span><span class=nx>scope</span><span class=p>,</span> <span class=nx>id</span><span class=p>,</span> <span class=nx>props</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>bucket</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>s3</span><span class=p>.</span><span class=nx>Bucket</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=s1>&#39;HelloRustBucket&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>enforceSSL</span>: <span class=kt>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>removalPolicy</span>: <span class=kt>cdk.RemovalPolicy.DESTROY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>autoDeleteObjects</span>: <span class=kt>true</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>rustHandler</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>rust</span><span class=p>.</span><span class=nx>RustFunction</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=s1>&#39;HelloRust&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>binaryName</span><span class=o>:</span> <span class=s1>&#39;rust_lambda&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>entry</span><span class=o>:</span> <span class=s1>&#39;rust_lambda&#39;</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>bucket</span><span class=p>.</span><span class=nx>grantReadWrite</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>rustHandler</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>bucket</span><span class=p>.</span><span class=nx>addEventNotification</span><span class=p>(</span><span class=nx>s3</span><span class=p>.</span><span class=nx>EventType</span><span class=p>.</span><span class=nx>OBJECT_CREATED</span><span class=p>,</span> <span class=k>new</span> <span class=nx>s3events</span><span class=p>.</span><span class=nx>LambdaDestination</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>rustHandler</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Whenever an object is created in the S3 bucket, the Rust Lambda function will be triggered, and its invocation event will contain a standard S3 event structure. We plan to implement a Lambda that processes the S3 event, for example, by deleting the object after processing it.</p><h2 id=writing-the-rust-lambda>Writing the Rust Lambda<a hidden class=anchor aria-hidden=true href=#writing-the-rust-lambda>#</a></h2><p>Our Rust Lambda can use the <a href=https://docs.rs/lambda_runtime/><code>lambda_runtime</code></a> and <a href=https://docs.rs/aws-sdk-s3/><code>aws-sdk-s3</code></a> crates. Here&rsquo;s a simplified example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>aws_config</span>::<span class=n>BehaviorVersion</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>aws_sdk_s3</span>::<span class=n>Client</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>S3Client</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>lambda_runtime</span>::<span class=p>{</span><span class=n>run</span><span class=p>,</span><span class=w> </span><span class=n>service_fn</span><span class=p>,</span><span class=w> </span><span class=n>tracing</span><span class=p>,</span><span class=w> </span><span class=n>Error</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>mod</span> <span class=nn>event_handler</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>event_handler</span>::<span class=n>function_handler</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[tokio::main]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>async</span><span class=w> </span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>Error</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tracing</span>::<span class=n>subscriber</span>::<span class=n>fmt</span><span class=p>().</span><span class=n>json</span><span class=p>().</span><span class=n>init</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>shared_config</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>aws_config</span>::<span class=n>load_defaults</span><span class=p>(</span><span class=n>BehaviorVersion</span>::<span class=n>v2025_01_17</span><span class=p>()).</span><span class=k>await</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s3_client</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>S3Client</span>::<span class=n>new</span><span class=p>(</span><span class=o>&amp;</span><span class=n>shared_config</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>run</span><span class=p>(</span><span class=n>service_fn</span><span class=p>(</span><span class=o>|</span><span class=n>event</span><span class=o>|</span><span class=w> </span><span class=n>function_handler</span><span class=p>(</span><span class=n>event</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>s3_client</span><span class=p>))).</span><span class=k>await</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Let&rsquo;s break this down:</p><ul><li>The <code>lambda_runtime</code> crate provides a couple of things: <code>run</code>, which is the main entry point for our Lambda function, and <code>service_fn</code>, which allows us to define a handler function that will be called with the event data. The <code>tracing</code> crate is used for <a href="https://github.com/awslabs/aws-lambda-rust-runtime?tab=readme-ov-file#tracing-and-logging">logging and more</a>, and we initialize it to output JSON logs.</li><li>The <a href=https://docs.rs/aws-config/latest/aws_config/><code>aws_config</code></a> crate provides implementations of region and credential resolution, which are used throughout the AWS SDK for Rust. The <code>aws_sdk_s3</code> crate provides the S3 client that we use to interact with S3. Similarly, if we wanted to use DynamoDB, we would use the <code>aws_sdk_dynamodb</code> crate.</li><li>Notice that we are using <a href=https://tokio.rs/>tokio</a>, which is an asynchronous runtime for Rust. This allows the <code>main()</code> method to use <code>async</code>/<code>await</code> syntax, which is very useful for I/O-bound tasks like network requests.</li><li>Finally, some variables are initialized in the <code>main()</code> method, such as <code>shared_config</code> and <code>s3_client</code>. These variables are <a href=https://docs.aws.amazon.com/lambda/latest/dg/rust-handler.html#rust-shared-state>shared</a> across Lambda invocations because they&rsquo;re part of the <a href=https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtime-environment.html#runtimes-lifecycle-ib>init phase</a>. This is where we want to put our expensive initialization code, as it avoids re-initializing the S3 client on every invocation.</li></ul><p>The <code>event_handler</code> module contains the logic for processing S3 events and deleting objects. You can see its full implementation in <a href=https://github.com/manmartgarc/cdk-lambda-rust/blob/main/rust_lambda/src/event_handler.rs>GitHub</a> â€” but it&rsquo;s not very complex; it just extracts the bucket name and object key from the S3 event and deletes the object using the S3 client.</p><h2 id=building-and-deploying>Building and Deploying<a hidden class=anchor aria-hidden=true href=#building-and-deploying>#</a></h2><p>If you just want to test the Rust code, you can run</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cargo <span class=nb>test</span>
</span></span></code></pre></div><p>In Rust, the <a href=https://doc.rust-lang.org/book/ch11-03-test-organization.html>convention</a> is to put the unit tests in the same file as the code, inside a <code>#[cfg(test)]</code> module. This means that you can run <code>cargo test</code> to run all the tests in your project, including the ones in the <code>event_handler.rs</code> module.</p><h3 id=local-lambda-testing>Local Lambda Testing<a hidden class=anchor aria-hidden=true href=#local-lambda-testing>#</a></h3><p>You can test your Lambda locally using <a href=https://www.cargo-lambda.info/>cargo-lambda</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cargo lambda watch
</span></span><span class=line><span class=cl><span class=c1># In another terminal:</span>
</span></span><span class=line><span class=cl>cargo lambda invoke -F s3-example.json
</span></span></code></pre></div><blockquote><p>Keep in mind that since the Lambda is triggered by S3 events, you will need to provide a valid S3 event payload when invoking the Lambda locally. The <code>--data-example s3-put</code> flag provides a sample S3 PUT event.</p></blockquote><p>When we are happy with our Rust code, we can build the Lambda binary and deploy it using CDK:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cdk deploy
</span></span></code></pre></div><p>The <a href=https://github.com/cdklabs/aws-lambda-rust>@cdklabs/aws-lambda-rust</a> CDK construct will handle packaging the Rust binary (using a Docker image with the Rust toolchain) and deploying the stack. The <code>cdk deploy</code> command will also create the S3 bucket and wire it up to the Lambda function. Now you can upload files to the S3 bucket, and the Lambda function will be triggered automatically â€” you can check the logs in CloudWatch to see the Lambda function processing the S3 events and also deleting the objects after processing them.</p><h2 id=architecture>Architecture<a hidden class=anchor aria-hidden=true href=#architecture>#</a></h2><p>Before we finish, I want to talk a little about the architecture of our CDK stack â€” specifically about using S3 events directly to trigger the Lambda function.</p><p>This is fine for a simple use case, like this one, where we just want to process S3 events and delete the objects. However, the main drawback of this approach is that any events that fail to be processed by the Lambda function will be lost. This is a serious issue, because <em>everything breaks all the time in production</em>.</p><p>A better approach is to use an SQS queue as an intermediary between the S3 bucket and the Lambda function. This way, we can gracefully handle two main failure modes:</p><ol><li>Events that are unable to be processed by the Lambda function (e.g., malformed events, or events that the Lambda function cannot handle). We can report back <a href=https://docs.aws.amazon.com/sdk-for-rust/latest/dg/rust_sqs_code_examples.html#serverless_examples>batch item failures to SQS</a>, so that even though the Lambda function succeeds, the events are sent back to the SQS queue for reprocessing later. If an event is sent back a certain number of times, we can send it to a dead-letter queue (DLQ) for further investigation.</li><li>Events that are not processed by the Lambda function due to a transient error (e.g., network issues, or the Lambda function being throttled). In this case, the SQS queue will automatically retry the event because we don&rsquo;t delete the message from the queue until the Lambda function successfully processes it. This means that we can handle transient errors gracefully, without losing any events.</li></ol><p>This retry mechanism is built into integrations between SQS and Lambda, so you don&rsquo;t have to implement it yourself. You can also use the <a href=https://docs.rs/aws-sdk-sqs/latest/aws_sdk_sqs/>AWS SDK for Rust</a> to send messages to the SQS queue from your Rust Lambda function, if you need to.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>With AWS CDK and the Rust Lambda ecosystem, you can quickly get started building high-performance serverless applications. The developer workflow is smooth: write your Lambda in Rust, define your infrastructure in TypeScript, and let CDK handle the rest!</p><p>ðŸ¦€ Happy building ðŸ¦€</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://manmartgarc.github.io/tags/aws/>Aws</a></li><li><a href=https://manmartgarc.github.io/tags/cloud/>Cloud</a></li><li><a href=https://manmartgarc.github.io/tags/rust/>Rust</a></li><li><a href=https://manmartgarc.github.io/tags/cdk/>Cdk</a></li></ul><nav class=paginav><a class=prev href=https://manmartgarc.github.io/posts/tech-support/go-lambda/><span class=title>Â« Prev</span><br><span>Lambda Functions with Go and CDK</span>
</a><a class=next href=https://manmartgarc.github.io/posts/tech-support/fastmcp-opendota/><span class=title>Next Â»</span><br><span>Building an MCP Server for OpenDota API with FastMCP</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://manmartgarc.github.io/>Manuel Martinez</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>